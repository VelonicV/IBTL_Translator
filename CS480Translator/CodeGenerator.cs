using System;
using System.Text;

namespace CS480Translator {

    //Type enums for function return types.
    public enum type { boolT, intT, realT, stringT, voidT }; 

    class CodeGenerator {

        //Root of the tree generated by the parserl
        private Tree.NonTerm root;

        //StringBuilder for appending code to.
        private StringBuilder code;

        //Counters for if and while functions, as well as global variables.
        private int f;
        private int w;
        private int v;

        private int line;
        private int character;

        //Flag for if currently in a definiton.
        private bool inDef;

        public CodeGenerator(String file) {

            Parser parser = new Parser(file);
            root = parser.returnTree();

            code = new StringBuilder();

            f = 0;
            w = 0;
            v = 0;
            line = 0;
            character = 0;
            inDef = false;

            init();
            start(root);

            code.Append("bye");
        }

        //Add library functions.
        private void init() {
            code.Append(": boolType if s\" true\" else s\" false\" endif type ;\n");
            code.Append(": n s\\\" \\n\" type ;\n");
            code.Append(": stringVar create 0 , 0 , ;\n");
        }

        //Starts generating code by looping through every non-terminal. 
        //If it's a term, it's guaranteed to be an ID or constant.
        private void start(Tree.NonTerm root) {

            foreach (Tree.IParseTree node in root.getList()) {

                if (node is Tree.NonTerm) {
                    unwrapSelect(node as Tree.NonTerm);
                }
                else {
                    Tree.Term nodeTerm = node as Tree.Term;
                    Tokens.GenericToken token = nodeTerm.getData();

                    if (token is Tokens.BCT || token is Tokens.ICT || token is Tokens.RCT || token is Tokens.SCT) {
                        constant(token);
                    }
                    else {
                        throw new Exception("GC Error: ID values not currently handled on line "
                            + nodeTerm.getLine() + ", character " + nodeTerm.getCharacter() + ".");
                    }
                }
            }
        }

        //Unwraps nested non-terminals, calling func when a terminal is found.
        private type unwrapSelect(Tree.NonTerm node) {

            if (node.getList().Count == 0) {
                return type.voidT;
            }
            else {
                Tree.IParseTree first = node.remove();
                if (first is Tree.NonTerm) {
                    return unwrapSelect(first as Tree.NonTerm);
                }
                else {
                    return func(first as Tree.Term, node);
                }
            }
        }

        //Selects function based on first operator.
        private type func(Tree.Term op, Tree.NonTerm pars) {

            Tokens.GenericToken token = op.getData();
            line = op.getLine();
            character = op.getCharacter();
            
            //First operator is a constant.
            if (token is Tokens.BCT || token is Tokens.ICT || token is Tokens.RCT || token is Tokens.SCT) {
                if (pars.getList().Count == 0) {
                    return constant(token);
                }
                else {
                    //We have an identical situation to start where the terms can only be IDs or constants.
                    //Print the constant and give the rest of the pars to start to deal with.
                    constant(token);
                    start(pars);
                    return type.voidT;
                }
            }
            else if (token is Tokens.BOT) {
                return boolOP(token as Tokens.BOT, pars);
            }
            else if (token is Tokens.RMOT) {
                return realMathOP(token as Tokens.RMOT, pars);
            }
            else if (token is Tokens.ROT) {
                return relOP(token as Tokens.ROT, pars);
            }
            else if (token is Tokens.MOT) {
                return mathOP(token as Tokens.MOT, pars);
            }
            else if (token is Tokens.CSOP) {
                return contextOP(token as Tokens.CSOP, pars);
            }
            else if (token is Tokens.KT) {
                return keywordOP(token as Tokens.KT, pars);
            }
            else {
                throw new Exception("GC Error: invalid token in function selector on line " 
                    + line + ", character " + character + "." );
            }
        }

        //Basic invalid return type error function.
        private type err(Tokens.GenericToken op) {

            throw new Exception("GC Error: invalid parameter type in '" + op.word + "' function on line "
                    + line + ", character " + character + ".");

        }

        //Keyword operator, parameters depends on the function.
        private type keywordOP(Tokens.KT op, Tree.NonTerm pars) {

            if (op.word == "stdout") {

                type first = getType(pars);
                if (first == type.stringT) {
                    code.Append("type n\n");
                }
                else if (first == type.intT) {
                    code.Append(". n\n");
                }
                else if (first == type.realT) {
                    code.Append("f. n\n");
                }
                else if (first == type.boolT) {
                    code.Append("boolType n\n");
                }
                else {
                    err(op);
                }
            }
            else if (op.word == "if") {

                type first = getType(pars);

                if (first == type.boolT) {

                    //If only structure
                    if (pars.getList().Count == 1) {

                        //We can't layer definitions within definitions, so we need to check whether we're defining one.
                        if (!inDef) {
                            code.Append(": f" + f + "\n");
                            inDef = true;

                            ifHelper(op, pars);

                            code.Append("; f" + f + "\n");
                            f++;
                            inDef = false;
                        }
                        else {
                            ifHelper(op, pars);
                        }                    
                    }
                    //If/Else structure
                    else {

                        if (!inDef) {
                            code.Append(": f" + f + "\n");
                            inDef = true;

                            ifElseHelper(op, pars);

                            code.Append("; f" + f + "\n");
                            f++;
                            inDef = false;
                        }
                        else {
                            ifElseHelper(op, pars);
                        }
                    }
                }
                else {
                    err(op);
                }
            }
            else if (op.word == "while") {

                if (!inDef) {

                    code.Append(": w" + w + "\n");
                    inDef = true;

                    whileHelper(op, pars);

                    code.Append("; w" + w + "\n");
                    w++;
                    inDef = false;
                }
                else {
                    whileHelper(op, pars);
                }
            }
            else if (op.word == "let") {
                letHelper(pars);
            }
            else {
                throw new Exception("GC Error: invalid keyword token in keyword function on line "
                        + line + ", character " + character + ".");
            }

            return type.voidT;

        }

        private void letHelper(Tree.NonTerm vars) {

        }

        //Outputs basic loop structure without taking definitions into account.
        private void whileHelper(Tokens.KT op, Tree.NonTerm pars) {

            code.Append("begin\n");

            type first = getType(pars);
            if (!(first == type.boolT)) {
                err(op);
            }

            code.Append("while\n");

            while (pars.getList().Count != 0) {
                getType(pars);
            }

            code.Append("repeat\n");

        }

        //Outputs basic if structure without taking definitions into account.
        private void ifHelper(Tokens.KT op, Tree.NonTerm pars) {

            code.Append("if\n");
            getType(pars);
            code.Append("endif\n");
        }

        //Outputs basic if/else structure without taking definitions into account
        private void ifElseHelper(Tokens.KT op, Tree.NonTerm pars) {

            code.Append("if\n");
            getType(pars);
            code.Append("else\n");
            getType(pars);
            code.Append("endif\n");

        }

        //Context sensitive operator, depends on input and number of parameters.
        private type contextOP(Tokens.CSOP op, Tree.NonTerm pars) {

            if (op.word == "+") {

                type first = getType(pars);
                type second = getType(pars);

                if ((first == type.stringT) && (second == type.stringT)) {
                    code.Append("s+\n");
                    return type.stringT;
                }
                else if ((first == type.intT) && (second == type.realT)) {
                    code.Append("s>f\n");
                }
                else if ((first == type.realT) && (second == type.intT)) {
                    code.Append("s>f\n");
                }
                else if ((first == type.intT) && (second == type.intT)) {
                    code.Append("+\n");
                    return type.intT;
                }
                else if ((first == type.realT) && (second == type.realT)) {
                    //no converting or swapping needed.
                }
                else {
                    return err(op);
                }

                code.Append("f+\n");
                return type.realT;

            }
            else {
                if (pars.getList().Count == 1) {

                    type first = getType(pars);

                    if (first == type.intT) {
                        code.Append("negate\n");
                        return type.intT;
                    }
                    else if (first == type.realT) {
                        code.Append("fnegate\n");
                        return type.realT;
                    }
                    else {
                        return err(op);
                    }
                }
                else {

                    type first = getType(pars);
                    type second = getType(pars);

                    if ((first == type.intT) && (second == type.realT)) {
                        code.Append("s>f\n");
                        code.Append("fswap\n");  
                    }
                    else if ((first == type.realT) && (second == type.intT)) {
                        code.Append("s>f\n");
                    }
                    else if ((first == type.intT) && (second == type.intT)) {
                        code.Append("-\n");
                        return type.intT;
                    }
                    else if ((first == type.realT) && (second == type.realT)) {
                        //no converting or swapping needed.
                    }
                    else {
                        return err(op);
                    }

                    code.Append("f-\n");
                    return type.realT;

                }
            }
        }

        //Math operations that take two parameters
        private type mathOP(Tokens.MOT op, Tree.NonTerm pars) {

            type first = getType(pars);
            type second = getType(pars);

            //Adjust and convert parameters as necessary
            if ((first == type.intT) && (second == type.realT)) {
                code.Append("s>f\n");
                code.Append("fswap\n");            
            }
            else if ((first == type.realT) && (second == type.intT)) {
                code.Append("s>f\n");
            }
            //Perform integer operations if both parameters are ints.
            else if ((first == type.intT) && (second == type.intT)) {

                if (op.word == "*") {
                    code.Append("*\n");
                }
                else if (op.word == "/") {
                    code.Append("/\n");
                }
                else if (op.word == "%") {
                    code.Append("mod\n");
                }
                else {
                    code.Append("s>f\n");
                    code.Append("s>f\n");
                    code.Append("fswap\n");
                    code.Append("f**\n");
                    code.Append("f>s\n");
                }

                return type.intT;
            }
            else if ((first == type.realT) && (second == type.realT)) {
                //no converting or swapping needed.
            }
            else {
                err(op);
            }

            //Real parameters, perform floating point operation.
            if (op.word == "*") {
                code.Append("f*\n");
            }
            else if (op.word == "/") {
                code.Append("f/\n");
            }
            else if (op.word == "%") {
                throw new Exception("GC Error: mod operation requires two integer parameters on line "
                        + line + ", character " + character + ".");
            }
            else {
                code.Append("f**\n");
            }

            return type.realT;
        }

        //Relational operator, takes in two parameters.
        private type relOP(Tokens.ROT op, Tree.NonTerm pars) {

            type first = getType(pars);
            type second = getType(pars);
            string opGforth;

            //Convert IBTL operator word to Gforth word
            if (op.word == "!=") {
                opGforth = "<>";
            }
            else {
                opGforth = op.word;
            }

            if ((first == type.intT) && (second == type.realT)) {
                code.Append("s>f\n");
                code.Append("f" + opGforth + "\n");
            }
            else if ((first == type.realT) && (second == type.intT)) {
                code.Append("s>f\n");
                code.Append("f" + opGforth + "\n");
            }
            else if ((first == type.intT) && (second == type.intT)) {
                code.Append(opGforth + "\n");
            }
            else if ((first == type.realT) && (second == type.realT)) {
                code.Append("f" + opGforth + "\n");
            }
            else {
                err(op);
            }

            return type.boolT;
        }

        //Real math operation, takes in one parameter.
        private type realMathOP(Tokens.RMOT op, Tree.NonTerm pars) {

            type first = getType(pars);
            if (first == type.intT) {
                code.Append("s>f\n");
            }
            else if (first != type.realT) {
                err(op);
            }

            code.Append("f" + op.word + "\n");

            return type.realT;
        }

        //Boolean operation, number of params guaranteed by grammar.
        private type boolOP(Tokens.BOT op, Tree.NonTerm pars) {

            //'not' function with one param.
            if (op.word == "not") {
                type first = getType(pars);

                if (first == type.boolT) {
                    code.Append("invert\n");
                }
                else {
                    err(op);
                }

            }
            //'and' or 'or' function with two params
            else {
                type first = getType(pars);
                type second = getType(pars);

                if ((first == type.boolT) && (second == type.boolT)) {
                    code.Append(op.word + "\n");
                }
                else {
                    err(op);
                }
            }

            return type.boolT;
        }

        //Get the first parameter and unwrap on the non-term or constant on term.
        private type getType(Tree.NonTerm pars) {

            type first;
            Tree.IParseTree firstPar = pars.remove();

            if (firstPar is Tree.Term) {
                Tree.Term firstParTerm = firstPar as Tree.Term;
                first = constant(firstParTerm.getData());
            }
            else {
                Tree.NonTerm firstParNon = firstPar as Tree.NonTerm;
                first = unwrapSelect(firstParNon);
            }

            return first;
        }

        //Token given is a constant, append it to the code and return its type.
        private type constant(Tokens.GenericToken token) {

            if (token is Tokens.BCT) {
                code.Append(token.word + "\n");
                return type.boolT;
            }
            else if (token is Tokens.ICT) {
                Tokens.ICT temp = (Tokens.ICT)token;
                code.Append(temp.integerValue + "\n");
                return type.intT;
            }
            else if (token is Tokens.RCT) {
                Tokens.RCT temp = (Tokens.RCT)token;
                code.Append(temp.realValue + "e\n");
                return type.realT;
            }
            else if (token is Tokens.SCT) {
                code.Append("s\" " + token.word + "\"\n");
                return type.stringT;
            }
            else {
                throw new Exception("GC Error: invalid token in constant function on line "
                        + line + ", character " + character + ".");
            }

        }

        //Return generated code;
        public string getCode() {
            return code.ToString();
        }
    }
}
